/**
 * Extract Data v2 - Extraction streaming hook
 * Phase 0: Mock implementation for UI scaffolding
 * Phase 1: Will implement fetch-based SSE client
 */

import { useState, useCallback } from 'react';
import { ExtractionStreamState, ExtractPhase } from '@/lib/types/extract-stream';

export interface UseExtractionStreamOptions {
  sessionId?: string;
  ocrEnabled?: boolean;
  extractionType?: 'summary' | 'tables' | 'entities' | 'structured';
}

export interface UseExtractionStreamReturn {
  state: ExtractionStreamState;
  start: (files: File[] | string[], options?: UseExtractionStreamOptions) => Promise<void>;
  stop: () => void;
  reset: () => void;
}

export function useExtractionStream(): UseExtractionStreamReturn {
  const [state, setState] = useState<ExtractionStreamState>({
    isStreaming: false,
    files: [],
    insights: [],
    timeline: [],
  });

  const start = useCallback(async (
    files: File[] | string[], 
    options?: UseExtractionStreamOptions
  ) => {
    // Phase 0: Mock implementation for UI scaffolding
    const mockFiles = Array.isArray(files) && files.length > 0 && files[0] instanceof File
      ? (files as File[]).map((file, index) => ({
          fileId: `mock-${index}`,
          name: file.name,
          size: file.size,
          phase: 'queued' as ExtractPhase,
          progress: 0,
        }))
      : (files as string[]).map((id, index) => ({
          fileId: id,
          name: `Document ${index + 1}.pdf`,
          size: 1024 * 1024,
          phase: 'queued' as ExtractPhase,
          progress: 0,
        }));

    setState(prev => ({
      ...prev,
      isStreaming: true,
      sessionId: options?.sessionId || `session-${Date.now()}`,
      files: mockFiles,
      timeline: [
        {
          timestamp: new Date(),
          phase: 'queued',
          message: `Started processing ${mockFiles.length} file(s)`,
        }
      ],
    }));

    // Phase 0: Simulate progress for UI testing
    // TODO Phase 1: Replace with actual SSE fetch to /api/extract/stream
    setTimeout(() => {
      setState(prev => ({
        ...prev,
        files: prev.files.map(f => ({ ...f, phase: 'parsing', progress: 25 })),
        timeline: [...prev.timeline, {
          timestamp: new Date(),
          phase: 'parsing',
          message: 'Parsing document structure...',
        }],
      }));
    }, 1000);

    setTimeout(() => {
      setState(prev => ({
        ...prev,
        files: prev.files.map(f => ({ ...f, phase: 'analyzing', progress: 50 })),
        insights: [{
          fileId: mockFiles[0]?.fileId || 'mock-0',
          summary: 'This is a mock summary for UI testing. The actual summary will be generated by the DataExtractionService.',
          keyPoints: [
            'Mock key point 1 for scaffolding',
            'Mock key point 2 for layout testing',
            'Mock key point 3 for component wiring'
          ],
        }],
        timeline: [...prev.timeline, {
          timestamp: new Date(),
          phase: 'analyzing',
          message: 'Analyzing content and extracting insights...',
        }],
      }));
    }, 2000);

    setTimeout(() => {
      setState(prev => ({
        ...prev,
        isStreaming: false,
        files: prev.files.map(f => ({ 
          ...f, 
          phase: 'completed', 
          progress: 100,
          extractionId: `extraction-${f.fileId}`,
        })),
        timeline: [...prev.timeline, {
          timestamp: new Date(),
          phase: 'completed',
          message: 'Extraction completed successfully',
        }],
      }));
    }, 3000);

  }, []);

  const stop = useCallback(() => {
    setState(prev => ({
      ...prev,
      isStreaming: false,
    }));
  }, []);

  const reset = useCallback(() => {
    setState({
      isStreaming: false,
      files: [],
      insights: [],
      timeline: [],
    });
  }, []);

  return {
    state,
    start,
    stop,
    reset,
  };
}
