/**
 * Extract Data v2 - Chat streaming hook
 * Phase 0: Mock implementation for UI scaffolding
 * Phase 3: Will implement fetch-based SSE client with conversation history
 */

import { useState, useCallback } from 'react';
import { ChatStreamState, ChatMessage } from '@/lib/types/extract-stream';

export interface UseExtractChatStreamOptions {
  sessionId?: string;
  fileId?: string;
  provider?: string;
  model?: string;
  temperature?: number;
}

export interface UseExtractChatStreamReturn {
  state: ChatStreamState;
  send: (messages: ChatMessage[], options?: UseExtractChatStreamOptions) => Promise<void>;
  abort: () => void;
  reset: () => void;
}

export function useExtractChatStream(): UseExtractChatStreamReturn {
  const [state, setState] = useState<ChatStreamState>({
    isStreaming: false,
    messages: [],
    currentResponse: '',
  });

  const send = useCallback(async (
    messages: ChatMessage[], 
    options?: UseExtractChatStreamOptions
  ) => {
    // Phase 0: Mock implementation for UI scaffolding
    setState(prev => ({
      ...prev,
      isStreaming: true,
      messages: [...messages],
      currentResponse: '',
    }));

    // Phase 0: Simulate streaming response for UI testing
    // TODO Phase 3: Replace with actual SSE fetch to /api/extract/chat/stream
    const mockResponse = "This is a mock response for UI testing. The actual response will be generated by the chat streaming API with full conversation context and document grounding.";
    
    let currentText = '';
    for (let i = 0; i < mockResponse.length; i++) {
      currentText += mockResponse[i];
      setState(prev => ({
        ...prev,
        currentResponse: currentText,
      }));
      
      // Simulate typing delay
      await new Promise(resolve => setTimeout(resolve, 20));
    }

    // Complete the response
    setState(prev => ({
      ...prev,
      isStreaming: false,
      messages: [
        ...messages,
        {
          role: 'assistant',
          content: mockResponse,
        }
      ],
      currentResponse: '',
      usage: { tokens: 150 }, // Mock token usage
    }));

  }, []);

  const abort = useCallback(() => {
    setState(prev => ({
      ...prev,
      isStreaming: false,
      currentResponse: '',
    }));
  }, []);

  const reset = useCallback(() => {
    setState({
      isStreaming: false,
      messages: [],
      currentResponse: '',
    });
  }, []);

  return {
    state,
    send,
    abort,
    reset,
  };
}
